% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sim.obs.data.R
\name{sim.obs.data}
\alias{sim.obs.data}
\title{Random linear model observed data generator}
\usage{
sim.obs.data(
  Xs,
  param.mat,
  family = "gaussian",
  link = "identity",
  sigma = NULL,
  lambda = NULL,
  N.trials = NULL,
  scale = NULL,
  size = NULL,
  random.slopes = FALSE,
  random.intercepts = FALSE,
  slope.int.covary = FALSE,
  var.covar.mat = NULL,
  rand.int.term = NULL,
  rand.nongroup.var = NULL,
  group.intercepts = NULL,
  mu.intercepts = NULL,
  sigma.intercepts = NULL,
  group.slopes = NULL,
  mu.slopes = NULL,
  sigma.slopes = NULL
)
}
\arguments{
\item{Xs}{A data frame containing 1 or more columns of X (independent variable) data. The data can be any combination of factors and quantitative data. However, the function will assume that the R-default factor levels, so custom factor levels will be ignored/lost.}

\item{param.mat}{Either a vector or a matrix with a single column containing the designed parameter values that should make up the parameter matrix within the linear predictor. If supplied as a vector, it will be internally coerced into a matrix. This should not be a data frame. The column need not be named. Logically, the number of values specified should match the number of parameters in your eventual design matrix (taking into account random effects and factor variable recoding) exactly; if this is not the case, the function will return an error to this effect. So, care needs to be taken to carefully consider the number of values required. In practice, if random slopes/intercepts are assumed, some of the initial values provided to this argument will be overridden with randomly selected values from a distribution with hyperoparameter values you specify.}

\item{family}{A single character element corresponding to the family of linear model to be simulated. Can take any of the following values: "gaussian", "gamma", "inverse.gaussian", "poisson", "bernoulli", "binomial", "negative.binomial". Defaults to "gaussian".}

\item{link}{A single character element corresponding to the link function of the linear model to be simulated. Can take any of the following values: "identity", "log", "inverse.squared", "logit", "sqrt", "inverse", "cloglog". Keep in mind that some family-link combinations would be non-standard and even potentially non-sensical, although the model will attempt to run any combination specified. Defaults to "identity". The only common linking function not currently implemented is the probit.}

\item{sigma}{A single numerical value corresponding to the standard deviation of the residual error distribution in a gaussian family model. Must be strictly >0. Defaults to NULL.}

\item{lambda}{A single numerical value corresponding to the shape parameter of the residual error distribution in an inverse-gaussian family model. Must be strictly >0. Defaults to NULL.}

\item{N.trials}{A vector of length = nrows(Xs) containing the number of trials involved in generating Binomial-family data that are not Bernoullian. Since these values essentially represent denominators in a positive fraction, they must all be strictly >0. Defaults to NULL.}

\item{scale}{A single numerical value corresponding to a scale parameter of the residual error distribution in an gamma family model. Must be strictly >0. Defaults to NULL.}

\item{size}{A single numerical value corresponding to a size parameter of the residual error distribution in a negative binomial family model. Must be strictly >0. Defaults to NULL.}

\item{random.slopes}{A single logical value (TRUE or FALSE) indicating whether random slopes should be assumed for some covariate based on a specified grouping variable. Defaults to FALSE. If set to TRUE, values for group.slopes, mu.slopes, and sigma.slopes must also be specified.}

\item{random.intercepts}{A single logical value (TRUE or FALSE) indicating whether random intercepts should be assumed for a specified grouping variable. Defaults to FALSE. If set to TRUE, values for group.intercepts, mu.intercepts, and sigma.intercepts must also be specified.}

\item{slope.int.covary}{A single logical value (TRUE or FALSE) indicating whether random intercepts and random slopes should be assumed to be covariable. Defaults to FALSE. If set to TRUE, random.slopes and random.intercepts must also be TRUE, and additionally a value for var.covar.mat must be supplied.}

\item{var.covar.mat}{A strictly square 2x2 matrix representing the desired variance-covariance matrix for drawing random correlated slope and intercept parameter values from a bivariate normal distribution (see Kery 2010, page 161 for details). The diagonal of this matrix should be equal to 1, and every value should be strictly between 0 and 1. In it's current form, the function can only handle random effects based on a single grouping variable.}

\item{rand.int.term}{A single character value. Defaults to NULL. When random.slopes = TRUE, a value for this parameter must be specified. The form required is very specific: It must be "X~:X^" where ~ is the column number in Xs of the grouping variable of the random effects and where ^ is the column number in Xs of a continuous covariate whose slopes will vary by levels of the grouping variable (it is also ok to reverse these two numbers). For example, if the grouping variable for which there will be random slopes is in column 7 of Xs and if the covariate for which these slopes will vary by group is in column 2, "X2:X7" or "X7:X2" are both acceptable forms.}

\item{rand.nongroup.var}{A single character value. Defaults to NULL. When random.slopes = TRUE, a value for this parameter must be specified. The form required is very specific: It must be "X^" where ^ is the column number in Xs of a continuous covariate whose slopes will vary by levels of the grouping variable (see under rand.int.term for more details).}

\item{group.intercepts}{A vector of length up to but not exceeding the length of param.mat. Defaults to NULL. When random.intercepts = TRUE, a value for group.intercepts must be provided. It should correspond to the position values in param.mat that hold the parameter estimates for the grouping variable that will have random intercepts. Keep in mind that the function will remove the global intercept term if random intercepts are assumed, which may affect which values in param.mat need to correspond to the grouping variable intercepts. See the examples for details. In the event that slope.int.covary is TRUE, values for group.intercepts and group.slopes need to be provide. These will then be concatenated internally (in that order), and the resulting vector cannot exceed param.mat in length.}

\item{mu.intercepts}{A single numerical value corresponding to the mean of the hyperdistribution from which new random intercept parameter values will be chosen, one for each group in the grouping variable specified. Defaults to NULL but must be provided if random.intercepts is TRUE.}

\item{sigma.intercepts}{A single numerical value corresponding to the standard deviation of the hyperdistribution from which new random intercept parameter values will be chosen, one for each group in the grouping variable specified. Defaults to NULL but must be provided if random.intercepts is TRUE.}

\item{group.slopes}{A vector of length up to but not exceeding the length of param.mat. Defaults to NULL. When random.slopes = TRUE, a value for group.slopes must be provided. It should correspond to the position values in param.mat that hold the parameter estimates for the continuous covariate variable that will have random slopes by group. See the examples for details. In the event that slope.int.covary is TRUE, values for group.intercepts and group.slopes need to be provided. These will then be concatenated internally (in that order), and the resulting vector cannot exceed param.mat in length.}

\item{mu.slopes}{A single numerical value corresponding to the mean of the hyperdistribution from which new random slope parameter values between Y and 1 continuous covariated specified will be chosen, one for each group in the grouping variable specified. Defaults to NULL but must be provided if random.slopes is TRUE.}

\item{sigma.slopes}{A single numerical value corresponding to the standard deviation of the hyperdistribution from which new random slope parameter values between Y and 1 continuous covariated specified will be chosen, one for each group in the grouping variable specified. Defaults to NULL but must be provided if random.slopes is TRUE.}
}
\value{
A list containing two vectors, /code{exp.ys} and /code\link{obs.ys}, which correspond to the expected and observed Y values simulated by the function, given the inputs.
}
\description{
Simulate random observed data based on input data and parameters.
}
\details{
The sim.obs.data function generates observed and expected
"generalized linear regression" response data utilizing independent
variable data, parameter values, model structure, and assumptions you
specify. It can handle most standard model families with their typical
linking functions, any number of covariates (including factors with
multiple levels that will need to be dummy coded), and random slopes and/or
intercepts based on a single grouping variable. However, the mechanics of
complex models will require inputs to be specified in a very specific
manner.

The function will assume there is a global intercept term in the model
unless random effects have been specified (in which case the model will
switch instead of mean encoding). The global intercept term could be
countered by setting the first value in param.mat to 0, but keep in mind
that that would effectively coerce the data to have a y intercept of 0,
which rarely makes sense.

If there are polynomial, interaction, or other complex terms in your model,
these should be precalculated and comprised within the input to Xs. In
other words, if you are trying to fit ~X1 + X2 + X1:X2, there should be a
column in your input to Xs that is already the product of X1 and X2, and
there should also be a corresponding beta term in the param.mat input
vector for this term.
}
\examples{
##This example shows a workflow for generating an entire simulated 
#data set (multiple X variables plus 1 Y variable) using sim.pred.data() plus 
#sim.obs.data that shows the typical syntax for a call to sim.obs.data plus 
#many of its features. It's a somewhat trivial case because it calls all 
#seven available families (with their standard linking functions) once using 
#the same input linear coefficient values even though the likely coefficient 
#values will tend to be very different for, as an example, a gamma model 
#versus a binomial one.

#Generates a predictor data set with two Xs, one numeric and one factorial.
Xstest = sim.data::sim.pred.data(col.num = 2, col.length = 25, 
         FUNs = c("rnorm", "sample"), factor.YN = c(FALSE, TRUE),
         x.sample = 0:2, replace = TRUE, sample.prob = c(0.4, 0.2, 0.4), 
         mean = 2, sd = 0.5)
print(Xstest) #shows what's we've made.

# we'll simulate one Y variable for each model family implemented using its 
#standard linking function.
family.test = c("gaussian", "gamma", "inverse.gaussian", "poisson", 
              "bernoulli", "binomial", "negative.binomial")
link.test = link = c("identity", "inverse", "inverse.squared", "log", 
            "logit", "logit", "log")

#We'll randomly draw parameter values for the specialized families from 
#plausible distributions.
sigma.test = runif(1, min=0.5, max=5)
lambda.test = runif(1, min=0.5, max=5)
N.trials.test = round(rnorm(length(Xstest[,1]), 40, 10))
scale.test = runif(1, min=0.5, max=5)
size.test = runif(1, min=0.5, max=5)
param.mat.test1 = c(0.1, 0.2, 2.5, -0.4) #The function will coerce this to a
#matrix with 1 column for you.

# we'll create empty matrices to store our output Y data.
record.obs = matrix(data = NA, nrow=length(Xstest[,1]), ncol=length(family.test))
record.exp = matrix(data = NA, nrow=length(Xstest[,1]), ncol=length(family.test))

#For each family-link combo, we'll call sim.obs.data to generate a set of 
#appropriate Y data. sim.obs.data will ignore inputs that are not essential 
#for the family being called.
for(trial in 1:length(family.test)) {
  test1 = sim.obs.data(Xs = Xstest, param.mat = param.mat.test1, 
          family = family.test[trial], link = link.test[trial], 
          sigma = sigma.test, lambda = lambda.test, N.trials = N.trials.test,
                      scale = scale.test, size = size.test, 
                      random.intercepts = TRUE,group.intercepts = 2:4, 
                      mu.intercepts = 1, sigma.intercepts = 0.5)
 record.obs[,trial] = test1$obs.ys #record the observed data generated.
 record.exp[,trial] = test1$exp.ys #record the "expected" data generated.
}

print(record.obs) ; print(record.exp) #Show what we've made. 
}
\author{
Alex Bajcz
}
